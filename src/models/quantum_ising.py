
from scipy.linalg import expm
import numpy as np
from functools import reduce

X_MATRIX = np.matrix([[0, 1], [1, 0]])
Z_MATRIX = np.matrix([[1, 0], [0, -1]])

class QuantumIsingModel:
    """ Quantum Ising model, using Hamiltonian
        H = -sum[i,j in R^d]{J_ij*sigma_i^z*sigma_j^z}-Gamma*sum[j]{sigma_j^x}
        """
    
    def __init__(self, node_count: int, gamma: float, beta: float):
        """ Constructor, given the number of nodes of the lattice, constant
            gamma and inverse temperate beta """
        self._node_count = node_count
        self._gamma = gamma
        self._beta = beta
        self._connections: dict[tuple[int, int], float] = {}

    @classmethod
    def from_string(self, text: str):
        """ Parse a string as generated by to_string() to create a Quantum Ising
            Model object """
        node_count, gamma, beta = None, None, None
        connections = {}
        for line in text.split("\n"):
            # Filter comments and split based on whitespace
            line = line.split("#", 1)[0].split()
            # Ignore empty lines
            if len(line) == 0 or line[0].startswith("#"):
                continue
            match line[0]:
                case "nodes":
                    assert len(line) == 2 and node_count is None
                    node_count = int(line[1])
                case "gamma":
                    assert len(line) == 2 and gamma is None
                    gamma = float(line[1])
                case "beta":
                    assert len(line) == 2 and beta is None
                    beta = float(line[1])
                case "connect":
                    assert len(line) == 4
                    i, j, s = int(line[1]), int(line[2]), float(line[3])
                    if i > j: i, j = j, i
                    assert connections.get((i, j), None) is None and i != j
                    connections[(i, j)] = s
                case _:
                    raise ValueError(f"Command not recognized: {line[0]}")
        if node_count == 0:
            raise ValueError("Missing node count")
        model = QuantumIsingModel(node_count, gamma if gamma is not None else 0,
        beta)
        model._connections = connections
        return model

    def to_string(self) -> str:
        """ Convert the Quantum Ising Model to a human-readable string, that can
            also be converted back to a QuantumIsingModel object """
        return (f"nodes {self._node_count}\ngamma {self._gamma}\nbeta " +
        f"{self._beta}\n" + "".join(f"connect {i} {j} {s}\n" for (i, j), s in
        self._connections.items()))

    def add_connection(self, i: int, j: int, strength: float, add_to_existing:
    bool = False):
        """ Add a connection between two nodes i and j with a given strength. If
            add_to_existing is set to True, this will not throw an error when a
            connection between the nodes already exists, and instead will sum
            the existing strength with the new strength """
        if i > j: i, j = j, i
        assert i != j
        if (not add_to_existing and self._connections.get((i, j), None) is not
        None):
            raise RuntimeError(f"Connection between nodes {i} and {j} already "
            "exists")
        self._connections.setdefault((i, j), 0)
        self._connections[(i, j)] += strength

    def partition_function(self) -> float:
        """ Returns the approximate partition function of the model, using a
            matrix exponentiation series approximation. This method is very slow
            for large models """
        # Partition function is Tr(e^(-beta*H))
        return expm(-self._beta * self.hamiltonian()).trace()

    def hamiltonian(self) -> np.matrix:
        """ Determine the Hamiltonian matrix of this model. This method is very
            slow for large models """
        current = np.zeros((2 ** self._node_count, 2 ** self._node_count))
        # Connections
        for (i, j), s in self._connections.items():
            current += s * reduce(np.kron, [
                np.identity(2 ** i),
                Z_MATRIX,
                np.identity(2 ** (j - i - 1)),
                Z_MATRIX,
                np.identity(2 ** (self._node_count - j - 1))
            ])
        # Constant
        current += self._gamma * reduce(np.kron, (X_MATRIX for _ in
        range(self._node_count)))
        return np.matrix(current)

    def __str__(self) -> str:
        """ Convert to string using the same format that from_string() uses """
        return self.to_string()